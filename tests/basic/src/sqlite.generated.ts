// This file is automatically generated by @rad/sqlite-generator.
// @generated 36da3a3c-42c7-4bb5-a74d-dc43937c0db6
import * as Runtime from "@rad/sqlite";
import { SQL, z } from "@rad/sqlite";

export const Doc = z.object({
  rowid: z.union([z.number(), z.bigint()]),
  id: z.string().uuid(),
  createdAt: z.date(),
  updatedAt: z.date(),
  isActive: z.boolean(),
  parentId: z.string().uuid().nullable(),
  content: z.string(),
  extra: z.unknown(),
});
export type Doc = z.infer<typeof Doc>;

export type WhereDoc = {
  rowid?: Runtime.WhereNumber;
  id?: Runtime.WhereUuid;
  createdAt?: Runtime.WhereDate;
  updatedAt?: Runtime.WhereDate;
  isActive?: Runtime.WhereBoolean;
  parentId?: Runtime.WhereUuid;
  content?: Runtime.WhereString;
  contentLength?: Runtime.WhereNumber;
  parent?: Runtime.WhereOneRelated<WhereDoc>;
  children?: Runtime.WhereManyRelated<WhereDoc>;
  AND?: Runtime.MaybeArray<WhereDoc>;
  OR?: Runtime.MaybeArray<WhereDoc>;
  NOT?: Runtime.MaybeArray<WhereDoc>;
};
export const WhereDoc: z.ZodSchema<WhereDoc> = z.lazy(() =>
  z
    .object({
      rowid: Runtime.WhereNumber.optional(),
      id: Runtime.WhereUuid.optional(),
      createdAt: Runtime.WhereDate.optional(),
      updatedAt: Runtime.WhereDate.optional(),
      isActive: Runtime.WhereBoolean.optional(),
      parentId: Runtime.WhereUuid.optional(),
      content: Runtime.WhereString.optional(),
      contentLength: Runtime.WhereNumber.optional(),
      parent: Runtime.WhereOneRelated(WhereDoc).optional(),
      children: Runtime.WhereManyRelated(WhereDoc).optional(),
      AND: Runtime.MaybeArray(WhereDoc).optional(),
      OR: Runtime.MaybeArray(WhereDoc).optional(),
      NOT: Runtime.MaybeArray(WhereDoc).optional(),
    })
    .strict()
);

export const OrderDocBy = z.object({
  rowid: Runtime.SortOrder.optional(),
  id: Runtime.SortOrder.optional(),
  createdAt: Runtime.SortOrder.optional(),
  updatedAt: Runtime.SortOrder.optional(),
  isActive: Runtime.SortOrder.optional(),
  parentId: Runtime.SortOrder.optional(),
  content: Runtime.SortOrder.optional(),
  contentLength: Runtime.SortOrder.optional(),
});
export type OrderDocBy = z.infer<typeof OrderDocBy>;

export const FindFirstDocArgs = z.object({
  where: WhereDoc.optional(),
  orderBy: Runtime.MaybeArray(OrderDocBy).optional(),
  offset: z.number().optional(),
});
export type FindFirstDocArgs = z.infer<typeof FindFirstDocArgs>;

export const FindManyDocArgs = z.object({
  where: WhereDoc.optional(),
  orderBy: Runtime.MaybeArray(OrderDocBy).optional(),
  limit: z.number().optional(),
  offset: z.number().optional(),
});
export type FindManyDocArgs = z.infer<typeof FindManyDocArgs>;

export const CreateDocArgs = z.object({
  data: Doc.partial(),
});
export type CreateDocArgs = z.infer<typeof CreateDocArgs>;

export const CreateManyDocArgs = z.object({
  data: Doc.partial().array(),
});
export type CreateManyDocArgs = z.infer<typeof CreateManyDocArgs>;

export const UpdateManyDocArgs = z.object({
  data: Doc.partial(),
  where: WhereDoc.optional(),
  orderBy: Runtime.MaybeArray(OrderDocBy).optional(),
  limit: z.number().optional(),
  offset: z.number().optional(),
});
export type UpdateManyDocArgs = z.infer<typeof UpdateManyDocArgs>;

export const DeleteManyDocArgs = z.object({
  where: WhereDoc.optional(),
  orderBy: Runtime.MaybeArray(OrderDocBy).optional(),
  limit: z.number().optional(),
  offset: z.number().optional(),
});
export type DeleteManyDocArgs = z.infer<typeof DeleteManyDocArgs>;

const formatWhereDoc = Runtime.makeWhereChainable(
  ({ alias, ns }: Runtime.Namespace.Result, where: WhereDoc) => {
    const components: SQL.Template[] = [];
    if (where.rowid !== undefined) {
      components.push(
        Runtime.formatWhereNumber(SQL`${alias}.${SQL.id("rowid")}`, where.rowid)
      );
    }
    if (where.id !== undefined) {
      components.push(
        Runtime.formatWhereUuid(SQL`${alias}.${SQL.id("id")}`, where.id)
      );
    }
    if (where.createdAt !== undefined) {
      components.push(
        Runtime.formatWhereDate(
          SQL`${alias}.${SQL.id("createdAt")}`,
          where.createdAt
        )
      );
    }
    if (where.updatedAt !== undefined) {
      components.push(
        Runtime.formatWhereDate(
          SQL`${alias}.${SQL.id("updatedAt")}`,
          where.updatedAt
        )
      );
    }
    if (where.isActive !== undefined) {
      components.push(
        Runtime.formatWhereBoolean(
          SQL`${alias}.${SQL.id("isActive")}`,
          where.isActive
        )
      );
    }
    if (where.parentId !== undefined) {
      components.push(
        Runtime.formatWhereUuid(
          SQL`${alias}.${SQL.id("parentId")}`,
          where.parentId
        )
      );
    }
    if (where.content !== undefined) {
      components.push(
        Runtime.formatWhereString(
          SQL`${alias}.${SQL.id("content")}`,
          where.content
        )
      );
    }
    if (where.contentLength !== undefined) {
      components.push(
        Runtime.formatWhereNumber(
          SQL`${alias}.${SQL.id("contentLength")}`,
          where.contentLength
        )
      );
    }
    if (where.parent !== undefined) {
      components.push(
        Runtime.formatWhereOne(
          ns.referenceTable("parent"),
          SQL`${alias}.${SQL.id("parentId")}`,
          SQL.id("tbl"),
          SQL.id("id"),
          where.parent,
          formatWhereDoc
        )
      );
    }
    if (where.children !== undefined) {
      components.push(
        Runtime.formatWhereMany(
          ns.referenceTable("children"),
          SQL`${alias}.${SQL.id("id")}`,
          SQL.id("tbl"),
          SQL.id("parentId"),
          where.children,
          formatWhereDoc
        )
      );
    }
    return components;
  }
);

function parseDoc(row: Record<string, unknown>): Doc {
  return {
    rowid: row.rowid as number | bigint,
    id: row.id as string,
    createdAt: new Date(row.createdAt as string),
    updatedAt: new Date(row.updatedAt as string),
    isActive: row.isActive != 0,
    parentId: row.parentId as string | null,
    content: row.content as string,
    extra: JSON.parse(row.extra as string),
  };
}

function serializeDoc(obj: Partial<Doc>): Record<string, SQL.RawValue> {
  const result: Record<string, SQL.RawValue> = {};
  for (const key in obj) {
    /* istanbul ignore if */
    if ((obj as any)[key] === undefined) continue;
    switch (key) {
      case "rowid":
        result[key] = obj[key];
        break;
      case "id":
        result[key] = obj[key];
        break;
      case "createdAt":
        result[key] = obj[key]?.toISOString();
        break;
      case "updatedAt":
        result[key] = obj[key]?.toISOString();
        break;
      case "isActive":
        result[key] = obj[key] === null ? null : +obj[key]!;
        break;
      case "parentId":
        result[key] = obj[key];
        break;
      case "content":
        result[key] = obj[key];
        break;
      case "extra":
        result[key] = JSON.stringify(obj[key]);
        break;
      /* istanbul ignore next */
      default:
        throw new Error(`invalid key ${key}`);
    }
  }
  return result;
}

function fillDocCreateData(data: Partial<Doc>): Partial<Doc> {
  return {
    id: Runtime.randomUuid(),
    createdAt: new Date(),
    updatedAt: new Date(),
    isActive: false,
    extra: {},
    ...data,
  };
}

function fillDocUpdateData(data: Partial<Doc>): Partial<Doc> {
  return { updatedAt: new Date(), ...data };
}

export class DocClient<
  ModelType = Doc
> extends Runtime.GenericClient<ModelType> {
  findFirst(args?: FindFirstDocArgs): ModelType | undefined {
    return this.findMany({ ...args, limit: 1 })[0];
  }

  findMany(args?: FindManyDocArgs): ModelType[] {
    const columns = SQL.join(
      [
        SQL.id("rowid"),
        SQL.id("id"),
        SQL.id("createdAt"),
        SQL.id("updatedAt"),
        SQL.id("isActive"),
        SQL.id("parentId"),
        SQL.id("content"),
        SQL.id("contentLength"),
        SQL.id("extra"),
      ],
      ", "
    );
    const parts: SQL.Template[] = [SQL.empty];
    if (args?.where !== undefined)
      parts.push(
        SQL`WHERE ${formatWhereDoc(Runtime.Namespace.root("tbl"), args.where)}`
      );
    if (args?.orderBy !== undefined)
      parts.push(Runtime.makeOrderBy(args.orderBy));
    if (args?.limit !== undefined || args?.offset !== undefined) {
      parts.push(SQL`LIMIT ${args?.limit ?? -1}`);
      if (args?.offset !== undefined) parts.push(SQL`OFFSET ${args.offset}`);
    }
    return this.$db
      .all(SQL`SELECT ${columns} FROM "tbl"${SQL.join(parts, " ")}`)
      .map((r) => this.transform(parseDoc(r)));
  }

  create(args: CreateDocArgs): ModelType {
    const data = fillDocCreateData(args.data);
    const result = this.$db.run(
      Runtime.makeInsert("tbl", [serializeDoc(data)])
    );
    return this.findFirst({ where: { rowid: result.lastInsertRowid } })!;
  }

  createMany(args: CreateManyDocArgs): Runtime.Database.RunResult {
    const data = args.data.map(fillDocCreateData).map(serializeDoc);
    return this.$db.run(Runtime.makeInsert("tbl", data));
  }

  updateMany(args: UpdateManyDocArgs): Runtime.Database.RunResult {
    const data = fillDocUpdateData(args.data);
    const parts: SQL.Template[] = [SQL.empty];
    if (args.where !== undefined)
      parts.push(
        SQL`WHERE ${formatWhereDoc(Runtime.Namespace.root("tbl"), args.where)}`
      );
    if (args.limit !== undefined || args.offset !== undefined) {
      parts.push(Runtime.makeOrderBy(args.orderBy ?? { rowid: "asc" }));
      parts.push(SQL`LIMIT ${args.limit ?? -1}`);
      if (args.offset !== undefined) parts.push(SQL`OFFSET ${args.offset}`);
    }
    return this.$db.run(
      SQL`${Runtime.makeUpdate("tbl", serializeDoc(data))}${SQL.join(
        parts,
        " "
      )}`
    );
  }

  deleteMany(args?: DeleteManyDocArgs): Runtime.Database.RunResult {
    const parts: SQL.Template[] = [SQL.empty];
    if (args?.where !== undefined)
      parts.push(
        SQL`WHERE ${formatWhereDoc(Runtime.Namespace.root("tbl"), args.where)}`
      );
    if (args?.limit !== undefined || args?.offset !== undefined) {
      parts.push(Runtime.makeOrderBy(args.orderBy ?? { rowid: "asc" }));
      parts.push(SQL`LIMIT ${args.limit ?? -1}`);
      if (args.offset !== undefined) parts.push(SQL`OFFSET ${args.offset}`);
    }
    return this.$db.run(SQL`DELETE FROM "tbl"${SQL.join(parts, " ")}`);
  }
}

export type Client<R> = {
  $db: Runtime.Database;
  docs: DocClient<R extends { docs: unknown } ? R["docs"] : Doc>;
};

export function createClient<R>(
  filename: string,
  options?: Runtime.Database.Options
): Client<R> {
  return Runtime.createClient(filename, options, {
    docs: DocClient,
  });
}
