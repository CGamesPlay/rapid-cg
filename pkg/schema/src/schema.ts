import _ from "lodash";
import pluralize from "pluralize";

import * as T from "./types.js";

/**
 * Base class for representing columns in \@rapid-cg schemas. This class is
 * never used directly; see the specific builders instead:
 *
 * - {@link s.blob}
 * - {@link s.boolean}
 * - {@link s.date}
 * - {@link s.integer}
 * - {@link s.json}
 * - {@link s.text}
 * - {@link s.uuid}
 */
export class ColumnAnyBuilder<DefaultType = never> {
  result: Omit<T.Column, "name">;

  constructor(input: Omit<T.Column, "name">) {
    this.result = input;
  }

  build(name: string): T.Column {
    return Object.assign({} as T.Column, this.result, { name });
  }

  protected withProperties(input: unknown): this {
    const ret = Object.create(Object.getPrototypeOf(this));
    ret.result = {};
    Object.assign(ret.result, this.result, input);
    return ret;
  }

  /**
   * Mark this column as the primary key for the table.
   *
   * @param primary Can be used to unset a previously-set primary flag.
   */
  primary(primary = true): this {
    return this.withProperties({ primary });
  }

  /**
   * Mark this column as unique. This will create a UNIQUE index on the column.
   *
   * @param unique Can be used to unset a previously-set unique flag.
   */
  unique(unique = true): this {
    return this.withProperties({ unique });
  }

  /**
   * Mark this column as nullable. This will remove the default NOT NULL
   * constraint from the column.
   *
   * @param nullable Can be used to unset a previously-set nullable flag.
   */
  nullable(nullable = true): this {
    return this.withProperties({ nullable });
  }

  /**
   * Provide a default value for this column. Default values are applied by the
   * generated code, not by the underlying database.
   */
  default(value: DefaultType): this {
    return this.withProperties({ default: value });
  }

  /**
   * Provide an SQL expression to use to generate the column (e.g. `ALWAYS
   * GENERATED AS` in SQL).
   */
  generatedAs(sql: string): this {
    return this.withProperties({ generatedAs: sql });
  }
}

export class ColumnBoolBuilder extends ColumnAnyBuilder<boolean> {}

export class ColumnDateBuilder extends ColumnAnyBuilder<Date> {
  mode: undefined | "createdAt" | "updatedAt";

  /**
   * Mark this column as a createdAt column. This will cause the generated
   * create methods for this model to automatically default this field to the
   * current date.
   */
  createdAt(): this {
    return this.withProperties({ mode: "createdAt" });
  }

  /**
   * Mark this column as an updatedAt column. This will cause the generated
   * create and update methods for this model to automatically default this
   * field to the current date.
   */
  updatedAt(): this {
    return this.withProperties({ mode: "updatedAt" });
  }
}

export class ColumnIntegerBuilder extends ColumnAnyBuilder<number | bigint> {
  /**
   * Mark this column as `PRIMARY KEY AUTOINCREMENT`. Overrides {@link primary}.
   */
  autoincrement(): this {
    return this.withProperties({ primary: "autoincrement" });
  }
}

export class ColumnUuidBuilder extends ColumnAnyBuilder<string> {
  /**
   * Mark this column as an autogenerated UUID. This will cause the generated
   * create methods for this model to default this field to a random UUID.
   */
  autogenerate(autogenerate = true): this {
    return this.withProperties({ autogenerate });
  }
}

/**
 * Base class for representing relations in \@rapid-cg schemas. This class is
 * never used directly; see the specific builders instead:
 *
 * - {@link s.belongsTo}
 * - {@link s.hasOne}
 * - {@link s.hasMany}
 */
export class RelationBuilder {
  result: Omit<T.RelationInput, "name">;

  constructor(input: Omit<T.RelationInput, "name" | "type">) {
    this.result = Object.assign({ type: "relation" }, input as any);
  }

  build(name: string): T.Relation {
    return Object.assign({} as T.Relation, this.result, { name });
  }
}

export class ModelBuilder {
  result: Partial<T.ModelSchema> = { columns: {}, relations: {} };

  build(name: string): T.ModelSchema {
    return Object.assign(
      { tableName: _.lowerFirst(pluralize(name)) },
      this.result,
      { name }
    ) as any;
  }

  protected withProperties(input: unknown): this {
    const ret = Object.create(Object.getPrototypeOf(this));
    ret.result = {};
    Object.assign(ret.result, this.result, input);
    return ret;
  }

  /**
   * Override the generated table name that backs this model. This can be used
   * to work with existing schemas or to use a different table naming
   * convention.
   */
  inTable(tableName: string): this {
    return this.withProperties({ tableName });
  }

  /**
   * Automatically add a {@link ColumnDateBuilder.createdAt} and
   * {@link ColumnDateBuilder.updatedAt} column to this model.
   */
  withTimestamps(): this {
    return this.withProperties({
      columns: {
        ...this.result.columns,
        createdAt: s.date().createdAt(),
        updatedAt: s.date().updatedAt(),
      },
    });
  }
}

/**
 * Main entry point for describing \@rapid-cg schemas.
 *
 * @see {@link s.database}
 * @see {@link s.model}
 */
export namespace s {
  export function blob(): ColumnAnyBuilder<Buffer> {
    return new ColumnAnyBuilder({ type: "blob" });
  }

  export function boolean(): ColumnBoolBuilder {
    return new ColumnBoolBuilder({ type: "boolean" });
  }

  export function date(): ColumnDateBuilder {
    return new ColumnDateBuilder({ type: "date" });
  }

  export function integer(): ColumnIntegerBuilder {
    return new ColumnIntegerBuilder({ type: "integer" });
  }

  export function json(): ColumnAnyBuilder<unknown> {
    return new ColumnAnyBuilder({ type: "json" });
  }

  export function text(): ColumnAnyBuilder<string> {
    return new ColumnAnyBuilder({ type: "text" });
  }

  export function uuid(): ColumnUuidBuilder {
    return new ColumnUuidBuilder({ type: "uuid" });
  }

  /**
   * Declare a N:1 relation from the current model to the foreign model.
   *
   * @param column The name of the column that stores the foreign key.
   * @param foreignModel The model name that the foreign key resides in.
   * @param foreignColumn The column in the foreignModel which is referenced.
   */
  export function belongsTo(
    column: string,
    foreignModel: string,
    foreignColumn: string
  ) {
    return new RelationBuilder({
      relationType: "belongsTo",
      column,
      foreignModel,
      foreignColumn,
    });
  }

  /**
   * Declare a 1:1 relation from the current model to the foreign model.
   *
   * @param column The name of the column that stores the foreign key.
   * @param foreignModel The model name that the foreign key resides in.
   * @param foreignColumn The column in the foreignModel which is referenced.
   */
  export function hasOne(
    column: string,
    foreignModel: string,
    foreignColumn: string
  ) {
    return new RelationBuilder({
      relationType: "hasOne",
      column,
      foreignModel,
      foreignColumn,
    });
  }

  /**
   * Declare a 1:N relation from the current model to the foreign model.
   *
   * @param column The name of the column that stores the foreign key.
   * @param foreignModel The model name that the foreign key resides in.
   * @param foreignColumn The column in the foreignModel which is referenced.
   */
  export function hasMany(
    column: string,
    foreignModel: string,
    foreignColumn: string
  ) {
    return new RelationBuilder({
      relationType: "hasMany",
      column,
      foreignModel,
      foreignColumn,
    });
  }

  /**
   * Build a schema for a single model. Columns should be named in
   * lowerCamelCase. Every column should either be a
   * {@link ColumnAnyBuilder | column builder} or
   * {@link RelationBuilder | relation builder}.
   */
  export function model(
    columns: Record<string, ColumnAnyBuilder<never> | RelationBuilder>
  ): ModelBuilder {
    const model = new ModelBuilder();
    for (let name in columns) {
      const result = columns[name].build(name);
      if (result.type === "relation") {
        model.result.relations![name] = result;
      } else {
        model.result.columns![name] = result;
      }
    }
    return model;
  }

  /**
   * Build a schema based on the provided models. Models should be named in
   * UpperCamelCase and singular (examples: `User`, `ExternalAcount`).
   *
   * @see {@link s.model}
   */
  export function database(
    models: Record<string, ModelBuilder>
  ): T.DatabaseSchema {
    const result: any = { models: {} as any };
    for (let name in models) {
      result.models[name] = models[name].build(name);
    }
    return T.DatabaseSchema.parse(result);
  }
}

export default s;
